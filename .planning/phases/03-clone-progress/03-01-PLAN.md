---
phase: 03-clone-progress
plan: 01
type: execute
wave: 1
depends_on: []
files_modified:
  - backend/src/git/mod.rs
  - backend/src/api/repos.rs
autonomous: true

must_haves:
  truths:
    - "Clone operation reports progress during object download phase"
    - "Clone operation reports progress during delta resolution phase"
    - "SSE endpoint streams progress events to connected clients"
    - "Progress events contain object counts and byte counts"
  artifacts:
    - path: "backend/src/git/mod.rs"
      provides: "CloneProgress struct and clone_with_progress function"
      contains: "pub struct CloneProgress"
    - path: "backend/src/api/repos.rs"
      provides: "SSE endpoint for clone progress"
      contains: "clone_with_progress_sse"
  key_links:
    - from: "backend/src/api/repos.rs"
      to: "backend/src/git/mod.rs"
      via: "clone_with_progress function call"
      pattern: "clone_with_progress"
    - from: "backend/src/api/repos.rs"
      to: "tokio::sync::mpsc"
      via: "channel for progress communication"
      pattern: "mpsc::channel"
---

<objective>
Add clone progress streaming to the backend using git2 progress callbacks and SSE.

Purpose: Enable real-time progress feedback during clone operations so users can see download status.
Output: Backend SSE endpoint that streams clone progress events (object counts, bytes, phases).
</objective>

<execution_context>
@~/.claude/get-shit-done/workflows/execute-plan.md
@~/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/phases/03-clone-progress/03-RESEARCH.md

@backend/src/git/mod.rs
@backend/src/api/repos.rs
</context>

<tasks>

<task type="auto">
  <name>Task 1: Add CloneProgress struct and clone_with_progress function</name>
  <files>backend/src/git/mod.rs</files>
  <action>
Add CloneProgress struct with fields matching git2 Progress:
- received_objects: usize
- total_objects: usize
- received_bytes: usize
- indexed_objects: usize
- total_deltas: usize
- indexed_deltas: usize

Add clone_with_progress function that:
1. Takes url: &str, dest: &Path, progress_tx: mpsc::Sender<CloneProgress>
2. Creates RemoteCallbacks with transfer_progress callback
3. In callback, construct CloneProgress from stats and use progress_tx.blocking_send()
4. Use try_send() to drop updates if channel full (natural throttling per research)
5. Configure FetchOptions with the callbacks
6. Use RepoBuilder::new().fetch_options(opts).clone(url, dest)
7. Return GitResult<git2::Repository>

Add derive Serialize to CloneProgress for JSON serialization.

Keep existing clone() function as-is for backwards compatibility.
  </action>
  <verify>cargo check --package ralphtown</verify>
  <done>CloneProgress struct exists with Serialize derive, clone_with_progress function compiles and accepts mpsc::Sender parameter</done>
</task>

<task type="auto">
  <name>Task 2: Add SSE clone endpoint</name>
  <files>backend/src/api/repos.rs</files>
  <action>
Add new SSE endpoint for clone with progress:

1. Add imports at top:
   - use axum::response::sse::{Event, KeepAlive, Sse}
   - use futures::stream::Stream
   - use std::convert::Infallible
   - use tokio::sync::mpsc

2. Create async fn clone_with_progress_sse that:
   - Takes State(state) and Query or Json for clone URL
   - Use Query params: url (required) - SSE is GET-based, can't use POST body
   - Returns Sse<impl Stream<Item = Result<Event, Infallible>>>
   - Creates mpsc::channel::<CloneProgress>(32) for bounded channel
   - Spawns tokio::task::spawn_blocking with clone_with_progress
   - Uses async_stream::stream! to convert channel to SSE stream
   - Each progress update serialized as JSON data event
   - On clone completion, sends "complete" event with repo JSON
   - On clone error, sends "error" event with error message
   - After clone success, inserts repo into database
   - Configures keep_alive with KeepAlive::default()

3. Add route to router():
   .route("/repos/clone-progress", get(clone_with_progress_sse))

4. Add CloneProgressQuery struct:
   #[derive(Debug, Deserialize)]
   pub struct CloneProgressQuery {
       pub url: String,
   }

Handle the spawn_blocking result to capture both success and error cases.
Send final "complete" or "error" event before stream ends.
  </action>
  <verify>cargo check --package ralphtown && cargo test --package ralphtown -- repos --nocapture</verify>
  <done>SSE endpoint /repos/clone-progress exists, compiles, handles progress streaming with complete/error events</done>
</task>

<task type="auto">
  <name>Task 3: Add async-stream dependency if needed</name>
  <files>backend/Cargo.toml</files>
  <action>
Check if async-stream is already in dependencies. If not, add:
async-stream = "0.3"

This is needed for the stream! macro to create async streams from the mpsc channel.

Note: Research indicated tokio_stream might have this, but async-stream is the standard crate for the stream! macro pattern shown in research.
  </action>
  <verify>cargo build --package ralphtown</verify>
  <done>async-stream dependency available, project builds successfully</done>
</task>

</tasks>

<verification>
1. cargo build --package ralphtown succeeds
2. cargo test --package ralphtown succeeds
3. CloneProgress struct is public and serializable
4. clone_with_progress function accepts progress channel
5. SSE endpoint route is registered at /repos/clone-progress
</verification>

<success_criteria>
- Backend compiles with new clone_with_progress function
- SSE endpoint exists and returns proper SSE response type
- Progress callback uses bounded channel with try_send for throttling
- Complete and error events are sent to signal stream end
</success_criteria>

<output>
After completion, create `.planning/phases/03-clone-progress/03-01-SUMMARY.md`
</output>
