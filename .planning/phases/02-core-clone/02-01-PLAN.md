---
phase: 02-core-clone
plan: 01
type: execute
wave: 1
depends_on: []
files_modified:
  - backend/src/git/mod.rs
  - backend/src/api/repos.rs
autonomous: true

must_haves:
  truths:
    - "POST /api/repos/clone with valid URL returns new Repo object"
    - "Clone creates directory at ~/ralphtown/{repo-name}"
    - "Cloned repo is added to database and appears in GET /api/repos"
  artifacts:
    - path: "backend/src/git/mod.rs"
      provides: "clone() function using git2 RepoBuilder"
      contains: "fn clone"
    - path: "backend/src/api/repos.rs"
      provides: "clone_repo handler with CloneRepoRequest/Response types"
      contains: "async fn clone_repo"
  key_links:
    - from: "backend/src/api/repos.rs"
      to: "backend/src/git/mod.rs"
      via: "GitManager::clone() call"
      pattern: "GitManager::clone"
    - from: "backend/src/api/repos.rs"
      to: "backend/src/db/mod.rs"
      via: "state.db.insert_repo() after clone"
      pattern: "state\\.db\\.insert_repo"
---

<objective>
Implement backend clone endpoint that accepts a git URL and clones to ~/ralphtown/{repo-name}.

Purpose: Enable the core clone workflow - backend receives URL, clones repo, adds to database, returns Repo object.
Output: POST /api/repos/clone endpoint that clones repos and registers them.
</objective>

<execution_context>
@~/.claude/get-shit-done/workflows/execute-plan.md
@~/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/phases/02-core-clone/02-RESEARCH.md
@backend/src/git/mod.rs
@backend/src/api/repos.rs
@backend/src/error.rs
</context>

<tasks>

<task type="auto">
  <name>Task 1: Add clone function to GitManager</name>
  <files>backend/src/git/mod.rs</files>
  <action>
Add a `clone()` function to GitManager that:
1. Takes `url: &str` and `dest: &Path` parameters
2. Uses `git2::build::RepoBuilder::new().clone(url, dest)` to clone
3. Returns `GitResult<git2::Repository>`
4. Maps git2 errors to `GitError::OperationFailed`

Important: This is a synchronous function (git2 is not async). The caller (API handler) will wrap in spawn_blocking.

Add test for clone to a temp directory.
  </action>
  <verify>
`cargo test --package ralphtown clone` passes with the new test
  </verify>
  <done>
GitManager::clone() function exists and can clone a git repo to a destination path
  </done>
</task>

<task type="auto">
  <name>Task 2: Add clone endpoint to repos API</name>
  <files>backend/src/api/repos.rs</files>
  <action>
Add clone endpoint following existing patterns:

1. Add request/response types:
```rust
#[derive(Debug, Deserialize, Serialize)]
pub struct CloneRepoRequest {
    pub url: String,
}

#[derive(Debug, Serialize, Deserialize)]
pub struct CloneRepoResponse {
    pub repo: Repo,
    pub message: String,
}
```

2. Add `extract_repo_name()` helper function:
   - Handle HTTPS URLs: `https://github.com/user/repo.git` -> `repo`
   - Handle SSH URLs: `git@github.com:user/repo.git` -> `repo`
   - Strip trailing `/` and `.git` suffix
   - Use rsplit('/') then rsplit(':') for SSH fallback
   - Return Err(AppError::BadRequest) if name is empty

3. Add `clone_repo` async handler:
   - Parse URL to extract repo name
   - Build destination: `dirs::home_dir()?.join("ralphtown").join(&repo_name)`
   - Check if destination already exists -> BadRequest error
   - Create parent directory with `std::fs::create_dir_all`
   - Clone using `tokio::task::spawn_blocking` to avoid blocking async runtime:
     ```rust
     let url_clone = req.url.clone();
     let dest_clone = dest.clone();
     tokio::task::spawn_blocking(move || {
         crate::git::GitManager::clone(&url_clone, &dest_clone)
     }).await.map_err(|e| AppError::Internal(e.to_string()))??;
     ```
   - Insert repo into database using existing `state.db.insert_repo()`
   - Return CloneRepoResponse with repo and success message

4. Add route: `.route("/repos/clone", post(clone_repo))`

5. Add test for clone endpoint (use a known public repo like https://github.com/octocat/Hello-World.git for testing, or mock)
  </action>
  <verify>
`cargo test --package ralphtown clone` passes with all clone-related tests
  </verify>
  <done>
POST /api/repos/clone endpoint exists, clones repo to ~/ralphtown/{name}, inserts into DB, returns Repo
  </done>
</task>

<task type="auto">
  <name>Task 3: Manual integration test</name>
  <files>None (verification only)</files>
  <action>
Start the backend server and test the clone endpoint manually:

1. Start server: `cargo run --package ralphtown`
2. Test clone with curl:
```bash
curl -X POST http://localhost:3000/api/repos/clone \
  -H "Content-Type: application/json" \
  -d '{"url": "https://github.com/octocat/Hello-World.git"}'
```
3. Verify response contains repo object with id, name, path
4. Verify directory exists at ~/ralphtown/Hello-World
5. Verify repo appears in `curl http://localhost:3000/api/repos`
6. Clean up: remove ~/ralphtown/Hello-World and delete from DB via API

If clone fails with auth error for private repos, that's expected - Phase 2 targets public repos only.
  </action>
  <verify>
curl POST to /api/repos/clone returns 200 with repo object, directory created, repo listed in /api/repos
  </verify>
  <done>
Clone endpoint works end-to-end for public repos
  </done>
</task>

</tasks>

<verification>
1. `cargo test --package ralphtown` - all tests pass
2. `cargo clippy --package ralphtown` - no warnings
3. Manual curl test shows clone working
</verification>

<success_criteria>
- POST /api/repos/clone accepts {url: string} and returns {repo: Repo, message: string}
- Cloned repo directory exists at ~/ralphtown/{repo-name}
- Cloned repo is automatically added to database
- GET /api/repos includes the newly cloned repo
</success_criteria>

<output>
After completion, create `.planning/phases/02-core-clone/02-01-SUMMARY.md`
</output>
