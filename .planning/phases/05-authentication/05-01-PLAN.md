---
phase: 05-authentication
plan: 01
type: execute
wave: 1
depends_on: []
files_modified:
  - backend/src/git/mod.rs
  - backend/src/api/repos.rs
  - backend/Cargo.toml
autonomous: true

must_haves:
  truths:
    - "Clone SSE endpoint accepts optional credentials in request body"
    - "Git2 credential callback uses state tracking to prevent infinite loops"
    - "SSH clone with passphrase works when passphrase provided"
    - "HTTPS clone with PAT/password works when credentials provided"
    - "Error response indicates whether auth retry with credentials is possible"
  artifacts:
    - path: "backend/src/git/mod.rs"
      provides: "Credentials enum, clone_with_credentials function, credential callback"
      contains: "struct CredentialState"
    - path: "backend/src/api/repos.rs"
      provides: "Updated CloneProgressQuery accepting credentials"
      contains: "CloneCredentials"
  key_links:
    - from: "backend/src/api/repos.rs"
      to: "backend/src/git/mod.rs"
      via: "clone_with_credentials call with credentials parameter"
      pattern: "clone_with_credentials.*credentials"
---

<objective>
Add credential callback support to git clone operations so clone can retry with user-provided credentials.

Purpose: Enable authentication retry flow - when initial clone fails due to auth, frontend can provide credentials and retry.
Output: Backend API that accepts credentials (SSH passphrase, GitHub PAT, HTTPS username/password) and uses them in git2 credential callback.
</objective>

<execution_context>
@~/.claude/get-shit-done/workflows/execute-plan.md
@~/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/05-authentication/05-CONTEXT.md
@.planning/phases/05-authentication/05-RESEARCH.md
@backend/src/git/mod.rs
@backend/src/api/repos.rs
@backend/src/error.rs
</context>

<tasks>

<task type="auto">
  <name>Task 1: Add credential types and helper functions</name>
  <files>backend/src/git/mod.rs</files>
  <action>
Add credential types and helper functions to git/mod.rs:

1. Add `Credentials` enum with three variants:
```rust
#[derive(Debug, Clone, Default)]
pub struct CloneCredentials {
    pub ssh_passphrase: Option<String>,
    pub ssh_key_path: Option<PathBuf>,
    pub username: Option<String>,
    pub password: Option<String>,  // Also used for GitHub PAT
}
```

2. Add `CredentialState` struct for tracking callback attempts:
```rust
#[derive(Default)]
struct CredentialState {
    tried_ssh_agent: bool,
    tried_ssh_key: bool,
    tried_userpass: bool,
}
```

3. Add `is_github_url(url: &str) -> bool` function that checks if URL contains "github.com"

4. Add `find_default_ssh_key() -> Result<PathBuf, git2::Error>` function that:
   - Gets home dir via dirs::home_dir()
   - Checks ~/.ssh/id_ed25519, ~/.ssh/id_ecdsa, ~/.ssh/id_rsa in order
   - Returns first existing key path, or error if none found

5. Update CloneError to include additional context:
```rust
#[derive(Debug, Error)]
pub enum CloneError {
    #[error("SSH authentication failed: {message}")]
    SshAuthFailed {
        message: String,
        help_steps: Vec<String>,
        needs_passphrase: bool,  // NEW: hint that passphrase may help
    },
    #[error("HTTPS authentication failed: {message}")]
    HttpsAuthFailed {
        message: String,
        help_steps: Vec<String>,
        is_github: bool,  // NEW: show PAT-specific UI
    },
    // ... keep existing variants
}
```

6. Update `classify_clone_error` to populate the new fields (needs_passphrase = true for SSH, is_github based on URL - will need URL parameter added).

Use `use std::path::PathBuf;` (already imported as Path).
  </action>
  <verify>cargo check passes in backend directory</verify>
  <done>Credentials types defined, helper functions implemented, CloneError enhanced with retry hints</done>
</task>

<task type="auto">
  <name>Task 2: Implement clone_with_credentials function</name>
  <files>backend/src/git/mod.rs</files>
  <action>
Add `clone_with_credentials` function to GitManager impl:

```rust
/// Clone a repository with optional credentials and progress reporting
///
/// This is a synchronous operation. Callers should use `tokio::task::spawn_blocking`.
///
/// The credential callback uses state tracking to prevent infinite loops when
/// libgit2 repeatedly requests credentials. Each auth method is tried once.
pub fn clone_with_credentials(
    url: &str,
    dest: &Path,
    credentials: Option<CloneCredentials>,
    progress_tx: mpsc::Sender<CloneProgress>,
) -> Result<git2::Repository, CloneError>
```

Implementation:
1. Create `Rc<RefCell<CredentialState>>` for callback state tracking
2. Set up RemoteCallbacks with:
   - `transfer_progress` callback (same as existing clone_with_progress)
   - `credentials` callback that:
     a. Checks `allowed.contains(CredentialType::SSH_KEY)`:
        - First try ssh-agent if not `state.tried_ssh_agent` (set flag, use `Cred::ssh_key_from_agent`)
        - Then try SSH key file if not `state.tried_ssh_key` (set flag, use credentials.ssh_key_path or find_default_ssh_key, use `Cred::ssh_key` with passphrase)
     b. Checks `allowed.contains(CredentialType::USER_PASS_PLAINTEXT)`:
        - If not `state.tried_userpass` and credentials has username/password, use `Cred::userpass_plaintext`
     c. Return `Err(git2::Error::from_str("all authentication methods failed"))` if all exhausted

3. Create FetchOptions with callbacks
4. Use RepoBuilder with fetch_options to clone
5. Map errors using `classify_clone_error` (pass URL for is_github detection)

Update `classify_clone_error` signature to take URL parameter for is_github detection:
```rust
pub fn classify_clone_error(err: git2::Error, url: &str) -> CloneError
```

Update existing `clone_with_progress` to delegate to `clone_with_credentials` with `None` credentials, or keep it separate but update error classification call.

NOTE: Use `std::cell::RefCell` and `std::rc::Rc` for the state (callback runs in blocking context, not async).
  </action>
  <verify>cargo check passes, cargo test -- --test-threads=1 passes (run tests single-threaded to avoid Rc issues)</verify>
  <done>clone_with_credentials function implemented with stateful credential callback</done>
</task>

<task type="auto">
  <name>Task 3: Update SSE endpoint to accept credentials</name>
  <files>backend/src/api/repos.rs</files>
  <action>
Update the clone-progress SSE endpoint to accept credentials:

1. Add request body type for POST (change from GET to POST):
```rust
#[derive(Debug, Deserialize, Default)]
pub struct CloneWithCredentialsRequest {
    pub url: String,
    #[serde(default)]
    pub credentials: Option<ApiCredentials>,
}

#[derive(Debug, Deserialize)]
#[serde(tag = "type", rename_all = "snake_case")]
pub enum ApiCredentials {
    SshPassphrase {
        passphrase: String,
        #[serde(default)]
        key_path: Option<String>,
    },
    GitHubPat {
        token: String,
    },
    HttpsBasic {
        username: String,
        password: String,
    },
}
```

2. Add conversion from ApiCredentials to CloneCredentials:
```rust
impl From<ApiCredentials> for CloneCredentials {
    fn from(api: ApiCredentials) -> Self {
        match api {
            ApiCredentials::SshPassphrase { passphrase, key_path } => CloneCredentials {
                ssh_passphrase: Some(passphrase),
                ssh_key_path: key_path.map(PathBuf::from),
                ..Default::default()
            },
            ApiCredentials::GitHubPat { token } => CloneCredentials {
                username: Some("x-access-token".to_string()),  // GitHub PAT convention
                password: Some(token),
                ..Default::default()
            },
            ApiCredentials::HttpsBasic { username, password } => CloneCredentials {
                username: Some(username),
                password: Some(password),
                ..Default::default()
            },
        }
    }
}
```

3. Create new handler `clone_with_credentials_sse` that:
   - Takes `Json<CloneWithCredentialsRequest>` body
   - Converts ApiCredentials to CloneCredentials
   - Calls `GitManager::clone_with_credentials` with credentials
   - Returns same SSE stream as before

4. Update router to add POST route:
```rust
.route("/repos/clone-progress", get(clone_with_progress_sse).post(clone_with_credentials_sse))
```

5. Update CloneEvent::Error to include retry hints:
```rust
Error {
    message: String,
    #[serde(skip_serializing_if = "Vec::is_empty", default)]
    help_steps: Vec<String>,
    #[serde(skip_serializing_if = "Option::is_none")]
    auth_type: Option<String>,  // "ssh", "github_pat", "https_basic"
    #[serde(skip_serializing_if = "std::ops::Not::not", default)]
    can_retry_with_credentials: bool,
}
```

Update error event construction in both handlers to populate auth_type based on CloneError variant and can_retry_with_credentials = true for auth failures.
  </action>
  <verify>cargo check passes, cargo test passes, manual test: curl -X POST with credentials JSON body</verify>
  <done>SSE endpoint accepts credentials via POST, error events include auth_type hints for frontend</done>
</task>

</tasks>

<verification>
All verification passes:
- cargo check
- cargo test (all existing tests pass)
- cargo clippy (no warnings)

Manual verification (optional):
- Clone public repo (no credentials needed) still works via GET
- Clone private repo without credentials returns auth error with auth_type hint
</verification>

<success_criteria>
- CloneCredentials type exists with ssh_passphrase, ssh_key_path, username, password fields
- CredentialState tracks tried_ssh_agent, tried_ssh_key, tried_userpass to prevent infinite callbacks
- clone_with_credentials accepts Optional<CloneCredentials> and uses credential callback
- POST /repos/clone-progress accepts JSON body with credentials
- CloneEvent::Error includes auth_type and can_retry_with_credentials hints
- All 79+ tests pass
</success_criteria>

<output>
After completion, create `.planning/phases/05-authentication/05-01-SUMMARY.md`
</output>
